//------------------------------------------------
//--- 010 Editor v16.0 Binary Template
//
//      File: .vdat
//   Authors: SolarCookies
//   Version: 0.1
//   Purpose: Reverse Viva Pinata Models
//  Category: Modding
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

//------------------------------------------------
//--- Color Meanings
// - cWhite, cGray, CLtGray, cDkGray = Unknown
// - cBlue, cDkBlue, cLtBlue = Offset
// - cYellow = Count
// - cDkRed = Size
// - cGreen = Float
// - cPurple,cLtPurple = String
// - cAqua = ID or Type
// - cRed = Flags
//
//
//------------------------------------------------


//BigEndian(); //Enable if its a TIP model


local int visitedOffsets[1024];
local int visitedCount = 0;
        
int AlreadyVisited(int offset) {
    for (int i = 0; i < visitedCount; i++) {
        if (visitedOffsets[i] == offset){
            return 1;
        }
    }
    return 0;
}
        
void MarkVisited(int offset) {
    visitedOffsets[visitedCount++] = offset;
}



local int offsetsToVisit[1024];
local int offsetCount = 0;
        
void AddOffsetToVisit(int offset) {
    if (offset != 0 && !AlreadyVisited(offset)) {
        offsetsToVisit[offsetCount++] = offset;
        MarkVisited(offset);
    }
}


struct ModelHeader{
    int HeaderOffset <bgcolor=cBlue>;
    int NumOfEntrys <bgcolor=cYellow>;
    int unk1;
    int unk2;
    int unk3;
} modelHeader <bgcolor=cGray>;

local struct EntryType{
    int ID <bgcolor=cAqua>;
    int Offset <bgcolor=cBlue>;
};

struct ModelFooter{
    EntryType Entry;
} modelFooter[modelHeader.NumOfEntrys] <optimize=true,pos=modelHeader.HeaderOffset, bgcolor=cBlack>;

for (int i = 0; i < modelHeader.NumOfEntrys; i++) { 
    
    if(i > sizeof(modelFooter) / sizeof(modelFooter[0])){
        continue;
    }
    
    // RENDERGRAPH
    if(modelFooter[i].Entry.ID == 0){ 
        struct RenderMan{
            int ModelInfoOffset <bgcolor=cBlue>;
            int Unk1;
            int Unk2;
            int Unk3;
            int TextureNamesOffset <bgcolor=cBlue>;
            int TextureMapsOffset <bgcolor=cBlue>;
            int NumberOfTextures <bgcolor=cYellow>;
            int unk5;
            int morphTargetTableOffset <bgcolor=cBlue>;
            int morphTargetTableCount <bgcolor=cYellow>;
            int inputDefinition1TableOffset <bgcolor=cBlue>;
            int inputDefinition1TableNumber <bgcolor=cYellow>;
            int inputDefinitionSize <bgcolor=cDkRed>;
            int inputDefinition2TableOffset <bgcolor=cBlue>;
            int inputDefinition2TableNumber <bgcolor=cYellow>;
            int unk10;
            int shadowMapNames <bgcolor=cBlue>;
            int NumberOfshadowMaps <bgcolor=cYellow>;
            int unk13;
            int unk14 <bgcolor=cBlue>;
            int unk14Count <bgcolor=cYellow>;
            int unk16; //Offset
            int unk16Count;
            int unk17;
            int unk18;
            int unk19;
            int unk20;
            int unk21;
            int unk22;
            int unk23;
            int unk24;
            int ClothOffset <bgcolor=cBlue>;
            int ClothCount <bgcolor=cYellow>;
            int unk27;
            int unk28;
            int unk29;
            float unk30 <bgcolor=cGreen>;
            float unk31 <bgcolor=cGreen>;
            int unk32;
        } renderman <pos=modelFooter[i].Entry.Offset, bgcolor=cBlack>;
        
        if(renderman.morphTargetTableCount != 0){
            FSeek(renderman.morphTargetTableOffset);
            struct MorphTargetTable{
                int block1;
                int block2;
                int number;
            } morphTargetTable[renderman.morphTargetTableCount] <bgcolor=cBlue>;
            
            local int Offset1 = renderman.morphTargetTableOffset + (12*renderman.morphTargetTableCount);
            for (int e = 0; e < renderman.morphTargetTableCount; e++) {
                FSeek(morphTargetTable[e].block1);
                Offset1 = morphTargetTable[e].block1;
                for (int y = 0; y < morphTargetTable[e].number; y++) {
                    
                    int Offset2 <bgcolor=cBlue>;
                    Offset1 += 4;
                    Printf( "%d\n", Offset2 );
                    struct MORPHTs {
                        string MORPHt <bgcolor=cDkPurple>;
                    } MORPHts <name="MORPHt",pos=Offset2>;
                }
            }
        }
        //Texture Names
        if(renderman.TextureNamesOffset != 0){
            struct TextureNamesOffsetEntry {
                int TextureOffset <bgcolor=cBlue>;
            } textureNamesOffsetEntry[renderman.NumberOfTextures] <optimize=true,pos=renderman.TextureNamesOffset, bgcolor=cBlack>;
            
            local string name1;
            
            for (int g = 0; g < renderman.NumberOfTextures; g++) {
                if(textureNamesOffsetEntry[g].TextureOffset != 0){
                    
                    SPrintf(name1, "TextureName%d", g);
                    
                    struct TextureNameStruct {
                        char TextureName[128] <bgcolor=cPurple>;
                    } textureNameStruct <name=name1, pos=textureNamesOffsetEntry[g].TextureOffset>;
                }
            }
        }
        
        //Texture Maps
        if(renderman.TextureMapsOffset != 0){
            struct TextureMapTable{
                int TextureMapOffset <bgcolor=cBlue>;
            } textureMapTable[renderman.NumberOfTextures] <optimize=true,pos=renderman.TextureMapsOffset, bgcolor=cBlack>;
            
            
            for (int t = 0; t < renderman.NumberOfTextures; t++) {
                struct TextureMaps {
                    string TextureMap <bgcolor=cPurple>;
                } textureMaps <name="TextureMapNames",pos=textureMapTable[t].TextureMapOffset>;
            }
        }
        
        // Input Definitions
        struct InputDefinitions1{
            char InputDefinitionType1[renderman.inputDefinitionSize] <bgcolor=cPurple,optimize=true>;
        }inputdefinitions1[renderman.inputDefinition1TableNumber] <optimize=true,pos=renderman.inputDefinition1TableOffset>;
        
        struct InputDefinitions2{
            char InputDefinitionType2[renderman.inputDefinitionSize] <bgcolor=cLtPurple,optimize=true>;
        }inputdefinitions2[renderman.inputDefinition2TableNumber] <optimize=true,pos=renderman.inputDefinition2TableOffset>;
        
        //Shadow Maps
        struct ShadowMapNamesOffsetEntry {
            int ShadowMapOffset <bgcolor=cBlue>;
        } shadowmapnamesOffsetEntry[renderman.NumberOfshadowMaps] <optimize=true,pos=renderman.shadowMapNames, bgcolor=cBlack>;
        
        for (int y = 0; y < renderman.NumberOfshadowMaps; y++) {
            struct ShadowMapNames {
                string ShadowMapName <bgcolor=cPurple>;
            } shadowMapName <name="ShadowMapNames",pos=shadowmapnamesOffsetEntry[y].ShadowMapOffset>;
        }
        
        //Unk16
        if(renderman.unk16 != 0){
            struct Unk16{
                char UnkChunk[72] <bgcolor=cWhite>;
            } unk16[renderman.unk16Count] <optimize=true,pos=renderman.unk16>;
        }
        
        //Unk14
        struct Unk14OffsetEntry {
            int Unk14Offset;
        } unk14OffsetEntry[renderman.unk14Count] <optimize=true,pos=renderman.unk14, bgcolor=cBlack>;
        
        for (int f = 0; f < renderman.unk14Count; f++) {
            struct Unk14 {
                string Unk14String <bgcolor=cPurple>;
            } unk14 <name="Unk14Strings",pos=unk14OffsetEntry[f].Unk14Offset, bgcolor=cBlack>;
        }
        
        if(renderman.ClothCount != 0){
            struct ClothOffsetEntry{
                char Unk[8] <bgcolor=cWhite>;
                int Offset1 <bgcolor=cBlue>;
                int Size1  <bgcolor=cYellow>;
                int Offset2 <bgcolor=cBlue>;
                int Size2  <bgcolor=cYellow>;
                int Offset3 <bgcolor=cBlue>;
                int Size3  <bgcolor=cYellow>;
            } clothOffsetEntry[renderman.ClothCount] <optimize=true,pos=renderman.ClothOffset>;
            
            
            local struct Cloth_Info_1{
                int Offset1 <bgcolor=cDkBlue>;
                int Unk1 <bgcolor=cWhite>;
                float x <bgcolor=cGreen>;
                float y <bgcolor=cGreen>;
                float z <bgcolor=cGreen>;
                int Offset2 <bgcolor=cBlue>;
                int Offset2Count <bgcolor=cYellow>;
                int Unk3 <bgcolor=cWhite>;
                int Offset3 <bgcolor=cBlue>;
                int Unk4 <bgcolor=cWhite>;
                int Unk5 <bgcolor=cWhite>;
                int Unk6 <bgcolor=cWhite>;
            };
            local struct Cloth_Info_2{
                int int1<bgcolor=cWhite>;
                int int2<bgcolor=cWhite>;
            };
            local struct Cloth_Info_3(int Size){
                char unk[Size]<bgcolor=cGray>;
            };
            local struct Cloth_Info_4{
                char unk[16]<bgcolor=cLtGray>;
            };
            
            local struct Cloth_Info_5{
                char unk[4]<bgcolor=cWhite>;
            };
            local struct Cloth_Info_6{
                char unk[6]<bgcolor=cGray>;
            };
            
            for (int y = 0; y < renderman.ClothCount; y++) {
               for (int a = 0; a < clothOffsetEntry[y].Size1; a++) {
                   FSeek(clothOffsetEntry[y].Offset1+a*48);
                   Cloth_Info_1 unk;
                   FSeek(unk.Offset1);
                   Cloth_Info_2 unk2;
                   if(unk.Offset2 != 0){
                     FSeek(unk.Offset2);
                     Cloth_Info_3 unk3(unk.Offset2Count*2);  
                   }
                   if(unk.Offset3 != 0){
                     FSeek(unk.Offset3);
                     Cloth_Info_4 unk4;  
                   }
               }
               for (int b = 0; b < clothOffsetEntry[y].Size2; b++) {
                   FSeek(clothOffsetEntry[y].Offset2+b*4);
                   Cloth_Info_5 unk;
               }
               for (int c = 0; c < clothOffsetEntry[y].Size3; c++) {
                   FSeek(clothOffsetEntry[y].Offset3+c*6);
                   Cloth_Info_6 unk;
               }
            }
        }
        
        // Entries typically follow after this header, their contents depend on the type.
        // Type 0 doesn't contain anything after it.
        // Type 1 is presumably the model definition.
        // Type 2 is vertice information.
        // Type 3 is unknown.
        // Type 4 is unknown.
        // Type 5 is unknown for purpose, contains a base size of 8 bytes, followed by several 2 byte entries.
        // Type 6 and Type 7 is indice information.
        local struct ModelInfo {
            uint8 Type <bgcolor=cAqua>;
            uint8 Flag2 <bgcolor=cRed>;
            uint8 Flag3 <bgcolor=cRed>;
            uint8 unk <bgcolor=cWhite>;
            int NextOffset <bgcolor=cBlue>;
            int AdditonalOffset <bgcolor=cDkBlue>;
            int LastOffset <bgcolor=cBlue>;
        };
        local struct ModelVertDef
        {
            short unk1 <bgcolor=cWhite>;
            short unk2 <bgcolor=cWhite>;
            int unk3 <bgcolor=cWhite>;
            int vertexCount <bgcolor=cYellow>;
            int dataOffset <bgcolor=cBlue>;
            int vertexOffset <bgcolor=cBlue>;
            int vertTableLength <bgcolor=cDkRed>;
            short entrySize <bgcolor=cDkRed>;
            short unk5 <bgcolor=cWhite>;
        };
        
        local struct ModelIndicesDef
        {
            int unk1;
        
            // Not entirely sure about this, as some models load the indices fine and others don't.
            int IndicesSize <bgcolor=cDkRed>;
            int IndicesCount <bgcolor=cYellow>;
            int unk4 <bgcolor=cWhite>;
            int IndicesCount2 <bgcolor=cYellow>;
            int unk6 <bgcolor=cWhite>;
            int IndicesOffset <bgcolor=cBlue>;
            char unk7[28] <bgcolor=cWhite>;
            int IndicesOffset2 <bgcolor=cBlue>;
            int IndicesOffset3 <bgcolor=cBlue>;
        };
        
        local struct VertDef
        {
            int unk1 <bgcolor=cWhite>;
            int unk2 <bgcolor=cWhite>;
            int unk3 <bgcolor=cWhite>;
            int unk4 <bgcolor=cWhite>;
            int Shader1_Start <bgcolor=cBlue>;
            int Shader1_End <bgcolor=cDkBlue>;
            char Unk5[24] <bgcolor=cWhite>;
            int VertDef_Start <bgcolor=cBlue>;
            int VertDef_End <bgcolor=cDkBlue>;
            int Shader2_Start <bgcolor=cBlue>;
            int Shader2_End <bgcolor=cDkBlue>;
            char Unk6[16] <bgcolor=cWhite>;
            int Shader4_Start <bgcolor=cBlue>;
            int Shader4_End <bgcolor=cDkBlue>;
            int Shader3_Start <bgcolor=cBlue>;
            int Shader3_End <bgcolor=cDkBlue>;
        };
        local struct FaceDef
        {
            int unk1 <bgcolor=cWhite>;
            int unk2 <bgcolor=cWhite>;
            int Shader1_Start <bgcolor=cBlue>;
            int Shader1_End <bgcolor=cDkBlue>;
            char Unk3[32] <bgcolor=cWhite>;
            int Shader2_Start <bgcolor=cBlue>;
            int Shader2_End <bgcolor=cDkBlue>;
            char Unk4[16] <bgcolor=cWhite>;
            int Shader4_Start <bgcolor=cBlue>;
            int Shader4_End <bgcolor=cDkBlue>;
            int Shader3_Start <bgcolor=cBlue>;
            int Shader3_End <bgcolor=cDkBlue>;
        };
        
        struct ShaderName(int size){
            char name[size] <bgcolor=cPurple>;
        };
        struct ShaderName2(int size){
            char name[size] <bgcolor=cLtPurple>;
        };
        struct VertDefBlock(int size){
            char unk[size] <bgcolor=cWhite>;
        };

        
        AddOffsetToVisit(renderman.ModelInfoOffset);
        
        local int currentOffset;
        local int LocalOffset;
        //Main Model Traversal Loop
        while (offsetCount > 0) {
            currentOffset = offsetsToVisit[--offsetCount];
            uint8 tmpType <pos=currentOffset>;
            FSeek(currentOffset);
            ModelInfo mi <pos=currentOffset, bgcolor=GetModelInfoTypeColor(mi.Type)>;
            LocalOffset = currentOffset + 16;
            if(mi.Type == 2){
              ModelVertDef vert <pos=LocalOffset, bgcolor=cBlack>;
            }
            else if(mi.Type == 6 || mi.Type == 7){
              ModelIndicesDef indices <pos=LocalOffset, bgcolor=cBlack>;
            }
            else if(mi.Type == 1){
              VertDef Vert <pos=LocalOffset, bgcolor=cBlack>;
              ShaderName shader1(Vert.Shader1_End - Vert.Shader1_Start) <pos=Vert.Shader1_Start>;
              ShaderName shader2(Vert.Shader2_End - Vert.Shader2_Start) <pos=Vert.Shader2_Start>;
              ShaderName shader3(Vert.Shader3_End - Vert.Shader3_Start) <pos=Vert.Shader3_Start>;
              ShaderName shader4(Vert.Shader4_End - Vert.Shader4_Start) <pos=Vert.Shader4_Start>;
              VertDefBlock unk(Vert.VertDef_End - Vert.VertDef_Start) <pos=Vert.VertDef_Start>;
            }
            else if(mi.Type == 3){
              FaceDef Face <pos=LocalOffset, bgcolor=cBlack>;
              ShaderName2 shader1(Face.Shader1_End - Face.Shader1_Start) <pos=Face.Shader1_Start>;
              ShaderName2 shader2(Face.Shader2_End - Face.Shader2_Start) <pos=Face.Shader2_Start>;
              ShaderName2 shader3(Face.Shader3_End - Face.Shader3_Start) <pos=Face.Shader3_Start>;
              ShaderName2 shader4(Face.Shader4_End - Face.Shader4_Start) <pos=Face.Shader4_Start>;
            }
            
            // Queue both Next and Additional offsets
            AddOffsetToVisit(mi.NextOffset);
            AddOffsetToVisit(mi.AdditonalOffset);
        }
    }
    if(modelFooter[i].Entry.ID == 24){
        struct UnkEntry2{
            int SomeSortOfOffset;
            float MaybeFloat;
        } unkEntry2 <pos=modelFooter[i].Entry.Offset,bgcolor=cBlue>;
    }
    if(modelFooter[i].Entry.ID == 5){
        struct UnkEntry3{
            char Data[64] <bgcolor=cGray>;
        } unkEntry3 <pos=modelFooter[i].Entry.Offset>;
    }
    if(modelFooter[i].Entry.ID == 4){
        struct UnkEntry4{
            char Data[72] <bgcolor=cYellow>;
        } unkEntry4 <pos=modelFooter[i].Entry.Offset>;
    }
    if(modelFooter[i].Entry.ID == 2){
        int Entry2Count <bgcolor=cLtBlue,pos=modelFooter[i].Entry.Offset>;
        local int EntrysOffset = modelFooter[i].Entry.Offset + 4;
        struct UnkEntry5{
            char Data[52] <bgcolor=cWhite>;
        } unkEntry5[Entry2Count] <optimize=true,pos=EntrysOffset>;
    }
    if(modelFooter[i].Entry.ID == 8){
        struct UnkEntry1{
            char Data[76] <bgcolor=cWhite>;
        } unkEntry1 <pos=modelFooter[i].Entry.Offset>;
    }
    //Printf( "%d\n", modelFooter[i].Entry.ID );
}

// Entries typically follow after this header, their contents depend on the type.
// Type 0 doesn't contain anything after it.
// Type 1 is presumably the model definition.
// Type 2 is vertice information.
// Type 3 is unknown.
// Type 4 is unknown.
// Type 5 is unknown for purpose, contains a base size of 8 bytes, followed by several 2 byte entries.
// Type 6 and Type 7 is indice information.
string GetModelInfoTypeName(uint8 &Type,int Offset){
    local string result = "Test";
    switch(Type){
       case 0  : result = "Empty"; break;
       case 1  : result = "Model Definition"; break;
       case 2  : result = "Vertice Information"; break;
       case 3  : result = "Indice Definition"; break;
       case 4  : result = "Unknown Type"; break;
       case 5  : result = "Unknown Type"; break;
       case 6  : result = "Indice Information"; break;
       case 7  : result = "Indice Information"; break;
       default : result = "Unknown Type";
    }
    //AppendWithCurrentOffset
    local string outStr;
    SPrintf(outStr, "%04d", Offset);
    result = result+" "+ outStr;
    return result;
}
int GetModelInfoTypeColor(uint8 &Type){
    local int result = cWhite;
    return cBlack;
    switch(Type){
       case 0  : result = cBlack; break;
       case 1  : result = cWhite; break;
       case 2  : result = cRed; break;
       case 3  : result = cGray; break;
       case 4  : result = cGray; break;
       case 5  : result = cGray; break;
       case 6  : result = cBlue; break;
       case 7  : result = cBlue; break;
       default : result = cGray;
    }
    return result;
}